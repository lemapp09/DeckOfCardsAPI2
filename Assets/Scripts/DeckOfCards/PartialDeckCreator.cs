using UnityEngine;
using UnityEngine.Networking;
using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;

public class PartialDeckCreator : MonoBehaviour
{
    [SerializeField] private Deck deck;
    public void StartCreatingPartialDeck()
    {
        GameManager.Instance.ClearTable();
        StartCoroutine(CreatePartialDeck());
    }

    IEnumerator CreatePartialDeck()
    {
        // List of specific cards
        string cards = "AS,2S,KS,AD,2D,KD,AC,2C,KC,AH,2H,KH";
        string url = $"https://deckofcardsapi.com/api/deck/new/shuffle/?cards={cards}";

        using (UnityWebRequest webRequest = UnityWebRequest.Get(url))
        {
            yield return webRequest.SendWebRequest();

            if (webRequest.result == UnityWebRequest.Result.ConnectionError || 
                webRequest.result == UnityWebRequest.Result.ProtocolError)
            {
                Debug.LogError("Error: " + webRequest.error);
            }
            else
            {
                string jsonResponse = webRequest.downloadHandler.text;
                Root myDeserializedClass = JsonConvert.DeserializeObject<Root>(jsonResponse);

                if (myDeserializedClass.success)
                {
                    Debug.Log("Partial Deck Created. Deck ID: " + myDeserializedClass.deck_id);
                    GameManager.Instance.UpdateDeckID(myDeserializedClass.deck_id);
                    GameManager.Instance.UpdateCardsRemaining(myDeserializedClass.remaining);
                    InstantiateCardPrefabs(cards);
                }
                else
                {
                    Debug.LogError("Failed to create a partial deck. Response: " + jsonResponse);
                }
            }
        }

    }
    
    private void InstantiateCardPrefabs(string cards)
    {
        string[] cardArray = cards.Split(',');
        int row = 0;
        int column = 0;
        float cardSpacing = 0.05f;
        float cardWidth = deck.allCards[0].cardData.cardPrefab.GetComponent<Renderer>().bounds.size.x;
        float cardHeight = deck.allCards[0].cardData.cardPrefab.GetComponent<Renderer>().bounds.size.y;
        float displayOffsetX = cardWidth * 6.5f + (cardSpacing * 6);
        float displayOffsetY = cardHeight * 2f + (cardSpacing * 1.5f);
        foreach (var card in cardArray)
        {
            // Use Deck's GetCard method to fetch the Card object
            Cards deckCard = deck.GetCard(card);
            if (deckCard != null && deckCard.cardData.cardPrefab != null)
            {
                GameObject cardObject = Instantiate(deckCard.cardData.cardPrefab, transform.position, Quaternion.identity);
                // Calculate position
                float posX = column * (cardWidth + cardSpacing);
                float posY = row * -(cardHeight + cardSpacing); // Negative for moving down
                cardObject.transform.localPosition = new Vector3(posX - displayOffsetX, 0.01f, posY + displayOffsetY);
                cardObject.transform.rotation = Quaternion.Euler(-90,0,0);
                cardObject.transform.SetParent(deck.transform);
               
                // Update row and column for next card
                column++;
                if (column > 12)
                {
                    column = 0;
                    row++;
                }
            }
        }
    }

    // Generated by  https://json2csharp.com/
    // Root class as defined
    public class Root
    {
        public bool success { get; set; }
        public string deck_id { get; set; }
        public bool shuffled { get; set; }
        public int remaining { get; set; }
    }
}